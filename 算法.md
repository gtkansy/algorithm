# 算法

- 判断一个链表是不是有环

  - 方法1：创建一个以节点ID为键的hashset集合，用来存储曾经遍历过得节点。每遍历到一个新节点，就用新节点和HashSet集合当中存储的节点作比较，如果发现HashSet当中存在相同节点ID，则说明链表有环。所以总体的时间复杂度是1*(D+S)=D+S，可以简单理解为O(N)。而算法的空间复杂度还是D+S-1，可以简单地理解成O(N)。

  - ==方法2==：首先创建两个指针1和2（在java里就是两个对象引用），同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针1每次向下移动一个节点，让指针2每次向下移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环。

    此方法也可以用一个更生动的例子来形容：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过，原因很简单，因为跑道是环形的。

- 找出缺失的整数(99个无序数组，值在1-100，差一个数，找出这个数)

  - 数组元素排序，然后遍历，相邻的差为1
  - 先算出1+2+3….+100的和，然后依次减去数组里的元素，最后得到的差，就是唯一缺失的整数。

- 统计买书：每本书只有一个编号（1-1000），但是不同的人喜欢同一本，所以需要去重和排序输出

  - 冒泡和快排等：先排序，输出时候注意就可以啦
  - 桶排序:  最快